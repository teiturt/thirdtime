"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Node = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const msgpack_1 = require("@msgpack/msgpack");
const core_1 = require("@logtail/core");
const context_1 = require("./context");
class Node extends core_1.Base {
    constructor(sourceToken, options) {
        super(sourceToken, options);
        // Sync function
        const sync = async (logs) => {
            const res = await cross_fetch_1.default(this._options.endpoint, {
                method: "POST",
                headers: {
                    "Content-Type": "application/msgpack",
                    Authorization: `Bearer ${this._sourceToken}`,
                    "User-Agent": "logtail-js(node)"
                },
                body: this.encodeAsMsgpack(logs)
            });
            if (res.ok) {
                return logs;
            }
            throw new Error(res.statusText);
        };
        // Set the throttled sync function
        this.setSync(sync);
    }
    /**
     * Override `Base` log to enable Node.js streaming
     *
     * @param message: string - Log message
     * @param level (LogLevel) - Level to log at (debug|info|warn|error)
     * @param log: (Partial<ILogtailLog>) - Initial log (optional)
     * @returns Promise<ILogtailLog> after syncing
     */
    async log(message, level, context = {}, stackContextHint) {
        // Process/sync the log, per `Base` logic
        context = Object.assign(Object.assign({}, context_1.getStackContext(this, stackContextHint)), context);
        const processedLog = await super.log(message, level, context);
        // Push the processed log to the stream, for piping
        if (this._writeStream) {
            this._writeStream.write(JSON.stringify(processedLog) + "\n");
        }
        // Return the transformed log
        return processedLog;
    }
    /**
     * Pipe JSON stringified `ILogtailLog` to a stream after syncing
     *
     * @param stream - Writable|Duplex stream
     */
    pipe(stream) {
        this._writeStream = stream;
        return stream;
    }
    encodeAsMsgpack(logs) {
        const maxDepth = this._options.contextObjectMaxDepth;
        const logsWithISODateFormat = logs.map((log) => (Object.assign(Object.assign({}, this.sanitizeForEncoding(log, maxDepth)), { dt: log.dt.toISOString() })));
        const encoded = msgpack_1.encode(logsWithISODateFormat);
        const buffer = Buffer.from(encoded.buffer, encoded.byteOffset, encoded.byteLength);
        return buffer;
    }
    sanitizeForEncoding(value, maxDepth, visitedObjects = new WeakSet()) {
        if (value === null || typeof value === "boolean" || typeof value === "number" || typeof value === "string") {
            return value;
        }
        else if (value instanceof Date) {
            // Date instances can be invalid & toISOString() will fail
            if (isNaN(value.getTime())) {
                return value.toString();
            }
            return value.toISOString();
        }
        else if ((typeof value === "object" || Array.isArray(value)) && (maxDepth < 1 || visitedObjects.has(value))) {
            if (visitedObjects.has(value)) {
                console.warn(`[Logtail] Found a circular reference when serializing logs. Please do not use circular references in your logs.`);
            }
            else if (this._options.contextObjectMaxDepthWarn) {
                console.warn(`[Logtail] Max depth of ${this._options.contextObjectMaxDepth} reached when serializing logs. Please do not use excessive object depth in your logs.`);
            }
            return value.toString(); // results in "[object Object]"
        }
        else if (Array.isArray(value)) {
            visitedObjects.add(value);
            const sanitizedArray = value.map((item) => this.sanitizeForEncoding(item, maxDepth - 1, visitedObjects));
            visitedObjects.delete(value);
            return sanitizedArray;
        }
        else if (typeof value === "object") {
            const logClone = {};
            visitedObjects.add(value);
            Object.entries(value).forEach(item => {
                const key = item[0];
                const value = item[1];
                const result = this.sanitizeForEncoding(value, maxDepth - 1, visitedObjects);
                if (result !== undefined) {
                    logClone[key] = result;
                }
            });
            visitedObjects.delete(value);
            return logClone;
        }
        else {
            return undefined;
        }
    }
}
exports.Node = Node;
//# sourceMappingURL=node.js.map